/**
 * Weave Protocol Fuzzer
 *
 * Fuzzing harness for decode_generate_request() using libFuzzer.
 * Tests the decoder with random byte inputs to find crashes, hangs,
 * and undefined behavior.
 *
 * Build:
 *   clang -fsanitize=fuzzer,address,undefined -O2 -g -I../include \
 *         -o fuzz_protocol fuzz_protocol.c ../src/protocol.c -lm
 *
 * Run:
 *   ./fuzz_protocol corpus/ -max_total_time=60
 *
 * AFL mode:
 *   Compile with afl-gcc and read from stdin instead of libFuzzer interface.
 */

#include <stdint.h>
#include <stddef.h>
#include "weave/protocol.h"

#ifdef AFL_MODE
#include <stdio.h>
#include <stdlib.h>

/**
 * AFL mode - Read input from stdin
 */
int main(void) {
    uint8_t buffer[MAX_MESSAGE_SIZE];
    size_t len = fread(buffer, 1, sizeof(buffer), stdin);

    sd35_generate_request_t req;
    decode_generate_request(buffer, len, &req);

    return 0;
}

#else

/**
 * libFuzzer entry point
 *
 * This function is called by libFuzzer with random byte sequences.
 * It should return 0 on success. The fuzzer tracks code coverage
 * and tries to maximize coverage by mutating inputs.
 *
 * @param data  Random byte sequence generated by fuzzer
 * @param size  Length of data buffer
 * @return      0 (return value doesn't matter for fuzzing)
 */
int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    /* Sanity check - skip empty inputs */
    if (data == NULL || size == 0) {
        return 0;
    }

    /* Skip inputs larger than max message size */
    if (size > MAX_MESSAGE_SIZE) {
        return 0;
    }

    /* Fuzz the decoder - we don't care about the result */
    sd35_generate_request_t req;
    (void)decode_generate_request(data, size, &req);

    /* Return 0 to continue fuzzing */
    return 0;
}

#endif
